# 逆序数与冒泡排序

在线性代数中，定义行列式的时候，我们接触了一个叫做**逆序数**的概念。

而我们知道，在排列里交换两个数的位置时，逆序数的奇偶性改变。由此，我们可以联想数的排序问题应该和逆序数有关。

## 逆序对和逆序数

一般地，对于$n$个两两不同的数的有序数组$(a_1, \dots, a_n)$（称为这$n$个数的一个**排列**,permutation；通常取$1,2,\dots,n$），若存在两个数$(a_i, a_j)$满足$i < j$且$a_i>a_j$，则这对数称为**逆序对**(inversion)；而逆序对的总数则称为这个排列的**逆序数**(inversion number)。

## 冒泡排序

给定$n$个数$a_1, \dots, a_n$构成的有序数组，我们希望找到一种算法，将这列数变成升序排列。其中最简单的一种算法便是**冒泡算法**(bubble sort)。

!!! Notation "冒泡排序算法"

    **Step 1** 我们先从数组的第一项$a_1$开始，若$a_1>a_2$，则交换两个数的位置；否则，不做任何操作。继续将第一步得到的$a_2$与$a_3$比较，若$a_2>a_3$，则交换两个数的位置；否则，不做任何操作。以此类推，继续比较至$a_{n-1},a_n$，Step 1结束。
    
    Step 1完成后，数组里最后一个数即为数组中最大的数。
    
    **Step 2** 继续上一步得到的数组，由于最后一个已经最大，我们只需要对前$n-1$个数做排序，这样，继续使用Step 1中的方法，从$a_1,a_2$比较至$a_{n-2},a_{n-1}$，Step 2结束。
    
    同样地，Step 2完成后，数组里倒数第二个数是数组里第二大的数。
    
    重复以上过程，到Step $n-1$之后，所有的数就排序完成了。
    
    ??? Question
    
        如何用数学归纳法证明这一个排序算法的正确性？

这一个算法可以用流程图表述如下：

```diagram
graph TB
	begin1(开始) --> input[/"输入数组a[0],...,a[n-1]"/]
	input --> i[i=1]
	i --> whilei{"i < n?"}
	whilei --Y--> j[j=0]
	j --> whilej{"j < n-i ?"}
	whilej --Y--> compare{"a[j] > a[j+1] ?"}
	compare --Y--> swap{"交换a[j], a[j+1]"}
	compare --N--> j++
	swap --> j++[j=j+1]
	j++ --> whilej
	whilej --N--> i++[i=i+1]
	i++ --> whilei
	whilei --N--> output[/"输出排序好的数组"/]
	output --> end1(结束)
```

??? Example "C语言示例"

    （可能有Bug，谨慎尝试）

    ```c
    #include <stdio.h>
    #include <string.h>

    int main()
    {
        int i, j;
        int a[] = {1,23,9,83,63,82,37,58}
        int n;
        n = sizeof(a)/sizeof(a[0]);
        for(i=1;i<n;i++)
        {
            for(j=0;j<n-i;j++)
            {
                if(a[j] > a[j+1]){
                    swap(&a[j], &a[j+1]);
                }
            }
        }
    }
    ```

## 冒泡排序与逆序数

在冒泡排序中，若给定的$n$个数两两不同，则交换的次数等于数组的逆序数。

!!! Proof
    
    设冒泡排序的交换次数为$s$，逆序数为$i$。
    
    冒泡排序中，每次交换都对应消除一对相邻的逆序对，而这两个数与其他数的逆序关系，以及其他数之间的逆序关系都不变，此时逆序数$i$减少1。
    
    当冒泡排序结束时，排列变成升序排列，逆序数减少到0。所以有$i-s=0$，即$i=s$。
